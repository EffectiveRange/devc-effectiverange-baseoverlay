# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# GitHub recommends pinning actions to a commit SHA.
# To get a newer version, you will need to update the SHA.
# You can also reference a tag or branch, but the action may change without warning.

name: Release

on:
  push:
    tags: 
      - "v*.*.*"
  repository_dispatch:
    types: [EffectiveRange/devc-effectiverange,EffectiveRange/packaging-tools]
    
jobs:
  prepare_release:
    name: Prepare release (compute vars, optionally tag)
    runs-on: ubuntu-latest
    permissions:
      contents: write
    concurrency:
      group: tagging-main
      cancel-in-progress: false
    outputs:
      tag: ${{ steps.out.outputs.tag }}
      version: ${{ steps.out.outputs.version }}
      base_image_version: ${{ steps.out.outputs.base_image_version }}
      dispatch_type: ${{ steps.out.outputs.dispatch_type }}
    steps:
      - name: Checkout (full history + tags)
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Compute tag/version/base_image_version (and optionally create tag)
        id: out
        shell: bash
        run: |
          set -euo pipefail

          EVENT="${GITHUB_EVENT_NAME}"
          dispatch_type=""
          base_image_version="latest"

          if [[ "$EVENT" == "repository_dispatch" ]]; then
            dispatch_type="$(jq -r .action "$GITHUB_EVENT_PATH")"

            # base image version policy per dispatch type
            case "$dispatch_type" in
              "EffectiveRange/devc-effectiverange")
                payload_version="$(jq -r '.client_payload.version // empty' "$GITHUB_EVENT_PATH")"
                if [[ -z "$payload_version" ]]; then
                  echo "Error: ${dispatch_type} requires client_payload.version" >&2
                  exit 1
                fi
                base_image_version="$payload_version"
                ;;
              "EffectiveRange/packaging-tools")
                base_image_version="latest"
                ;;
              *)
                echo "Error: unexpected repository_dispatch type: ${dispatch_type}" >&2
                exit 1
                ;;
            esac

            # Compute next patch tag based on latest tag merged into origin/main, then bump patch.
            git fetch origin main --tags --force

            latest_tag="$(git tag --merged origin/main \
              --list 'v[0-9]*.[0-9]*.[0-9]*' --sort=-v:refname | head -n 1)"

            if [[ -z "${latest_tag}" ]]; then
              echo "Error: No vX.Y.Z tags found on origin/main to bump." >&2
              exit 1
            fi

            IFS='.' read -r major minor patch <<< "${latest_tag#v}"
            new_patch=$((patch + 1))
            tag="v${major}.${minor}.${new_patch}"

            echo "Dispatch type:       ${dispatch_type}"
            echo "Latest tag on main:  ${latest_tag}"
            echo "New tag to create:   ${tag}"
            echo "Base image version:  ${base_image_version}"

            # Ensure we're on main HEAD
            git checkout -B main origin/main

            # HARD FAIL if the computed tag already exists (no reuse)
            if git ls-remote --tags origin "${tag}" | grep -q "${tag}$"; then
              echo "Error: tag ${tag} already exists on origin. Refusing to reuse." >&2
              exit 1
            fi
            if git rev-parse -q --verify "refs/tags/${tag}" >/dev/null; then
              echo "Error: tag ${tag} already exists locally. Refusing to reuse." >&2
              exit 1
            fi

            git tag -a "${tag}" -m "Automated patch release ${tag} (${dispatch_type})"
            git push origin "refs/tags/${tag}"

          else
            # push tag event
            tag="${GITHUB_REF#refs/tags/}"
            base_image_version="latest"
            echo "Triggered by tag push: ${tag}"
          fi

          version="${tag#v}"

          echo "dispatch_type=${dispatch_type}" >> "$GITHUB_OUTPUT"
          echo "tag=${tag}" >> "$GITHUB_OUTPUT"
          echo "version=${version}" >> "$GITHUB_OUTPUT"
          echo "base_image_version=${base_image_version}" >> "$GITHUB_OUTPUT"


  call_build_and_publish_images-armhf-bookworm:
    needs: prepare_release
    uses: ./.github/workflows/docker-image-single.yml
    secrets: inherit
    with:
      arch: "armhf"
      base_ver:  ${{needs.prepare_release.outputs.base_image_version}}
      version: ${{needs.prepare_release.outputs.version}}
      distro: "bookworm"


  call_build_and_publish_images-arm64-bookworm:
    needs: prepare_release
    uses: ./.github/workflows/docker-image-single.yml
    secrets: inherit
    with:
      arch: "arm64"
      base_ver:  ${{needs.prepare_release.outputs.base_image_version}}
      version: ${{needs.prepare_release.outputs.version}}
      distro: "bookworm"

  call_build_and_publish_images-amd64-bookworm:
    needs: prepare_release
    uses: ./.github/workflows/docker-image-single.yml
    secrets: inherit
    with:
      arch: "amd64"
      base_ver: ${{needs.prepare_release.outputs.base_image_version}}
      version: ${{needs.prepare_release.outputs.version}}
      distro: "bookworm"
    
  call_build_and_publish_images-armhf-trixie:
    needs: prepare_release
    uses: ./.github/workflows/docker-image-single.yml
    secrets: inherit
    with:
      arch: "armhf"
      base_ver:  ${{needs.prepare_release.outputs.base_image_version}}
      version: ${{needs.prepare_release.outputs.version}}
      distro: "trixie"


  call_build_and_publish_images-arm64-trixie:
    needs: prepare_release
    uses: ./.github/workflows/docker-image-single.yml
    secrets: inherit
    with:
      arch: "arm64"
      base_ver:  ${{needs.prepare_release.outputs.base_image_version}}
      version: ${{needs.prepare_release.outputs.version}}
      distro: "trixie"

  call_build_and_publish_images-amd64-trixie:
    needs: prepare_release
    uses: ./.github/workflows/docker-image-single.yml
    secrets: inherit
    with:
      arch: "amd64"
      base_ver: ${{needs.prepare_release.outputs.base_image_version}}
      version: ${{needs.prepare_release.outputs.version}}
      distro: "trixie"


  create_release:
    name: Create Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
      discussions: write
    needs: [call_build_and_publish_images-armhf-bookworm,call_build_and_publish_images-amd64-bookworm,call_build_and_publish_images-arm64-bookworm,call_build_and_publish_images-armhf-trixie,call_build_and_publish_images-amd64-trixie,call_build_and_publish_images-arm64-trixie]
    steps:
      - name: Checkout
        uses: actions/checkout@v6
      - name: Release
        uses: softprops/action-gh-release@v2



